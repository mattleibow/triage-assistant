import { jest } from '@jest/globals'
import * as github from '@actions/github'
import * as core from '@actions/core'
import * as fs from 'fs'
import {
  commentOnIssue,
  applyLabelsToIssue,
  addEyes,
  removeEyes,
  getIssueDetails
} from '../src/github-issues.js'
import { TriageResponse } from '../src/triage-response.js'
import { GitHubIssueConfig, TriageConfig } from '../src/triage-config.js'

// Mock fs
jest.mock('fs', () => ({
  promises: {
    readFile: jest.fn()
  }
}))

// Mock GitHub API
const mockCreateComment = jest.fn()
const mockAddLabels = jest.fn()
const mockCreateForIssue = jest.fn()
const mockListForIssue = jest.fn()
const mockDeleteForIssue = jest.fn()
const mockGetIssue = jest.fn()
const mockListComments = jest.fn()

const mockOctokit = {
  rest: {
    issues: {
      createComment: mockCreateComment,
      addLabels: mockAddLabels,
      get: mockGetIssue,
      listComments: mockListComments
    },
    reactions: {
      createForIssue: mockCreateForIssue,
      listForIssue: mockListForIssue,
      deleteForIssue: mockDeleteForIssue
    }
  }
} as unknown as ReturnType<typeof github.getOctokit>

// Mock @actions/core
jest.mock('@actions/core', () => ({
  info: jest.fn(),
  warning: jest.fn()
}))

const mockConfig: GitHubIssueConfig & TriageConfig = {
  repoOwner: 'test-owner',
  repoName: 'test-repo',
  issueNumber: 123,
  dryRun: false,
  token: 'test-token',
  tempDir: '/tmp'
}

const mockTriageResponse: TriageResponse = {
  labels: [
    { label: 'bug', confidence: 0.9 },
    { label: 'priority:high', confidence: 0.8 }
  ],
  comment: 'This looks like a bug',
  needsMoreInfo: false
}

describe('GitHub Issues', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe('commentOnIssue', () => {
    it('should create comment from summary file', async () => {
      const mockSummary = 'This is a test summary'
      const mockFooter = 'Generated by AI'
      ;(fs.promises.readFile as jest.Mock).mockResolvedValue(mockSummary)

      await commentOnIssue(mockOctokit, '/tmp/summary.txt', mockConfig, mockFooter)

      expect(fs.promises.readFile).toHaveBeenCalledWith('/tmp/summary.txt', 'utf8')
      expect(mockCreateComment).toHaveBeenCalledWith({
        owner: 'test-owner',
        repo: 'test-repo',
        issue_number: 123,
        body: `
${mockSummary}

${mockFooter}
`
      })
    })

    it('should skip empty comments', async () => {
      ;(fs.promises.readFile as jest.Mock).mockResolvedValue('')

      await commentOnIssue(mockOctokit, '/tmp/summary.txt', mockConfig, '')

      expect(mockCreateComment).not.toHaveBeenCalled()
    })

    it('should skip comments in dry run mode', async () => {
      const dryRunConfig = { ...mockConfig, dryRun: true }
      ;(fs.promises.readFile as jest.Mock).mockResolvedValue('Test summary')

      await commentOnIssue(mockOctokit, '/tmp/summary.txt', dryRunConfig, 'Footer')

      expect(mockCreateComment).not.toHaveBeenCalled()
      expect(core.info).toHaveBeenCalledWith(
        expect.stringContaining('Dry run: Skipping commenting on issue')
      )
    })

    it('should handle comment without footer', async () => {
      const mockSummary = 'Test summary'
      ;(fs.promises.readFile as jest.Mock).mockResolvedValue(mockSummary)

      await commentOnIssue(mockOctokit, '/tmp/summary.txt', mockConfig)

      expect(mockCreateComment).toHaveBeenCalledWith({
        owner: 'test-owner',
        repo: 'test-repo',
        issue_number: 123,
        body: `
${mockSummary}

undefined
`
      })
    })

    it('should handle file read errors', async () => {
      ;(fs.promises.readFile as jest.Mock).mockRejectedValue(new Error('File not found'))

      await expect(
        commentOnIssue(mockOctokit, '/tmp/summary.txt', mockConfig)
      ).rejects.toThrow('File not found')
    })

    it('should handle GitHub API errors', async () => {
      ;(fs.promises.readFile as jest.Mock).mockResolvedValue('Test summary')
      mockCreateComment.mockRejectedValue(new Error('API error'))

      await expect(
        commentOnIssue(mockOctokit, '/tmp/summary.txt', mockConfig)
      ).rejects.toThrow('API error')
    })
  })

  describe('applyLabelsToIssue', () => {
    it('should apply labels from triage response', async () => {
      await applyLabelsToIssue(mockOctokit, mockTriageResponse, mockConfig)

      expect(mockAddLabels).toHaveBeenCalledWith({
        owner: 'test-owner',
        repo: 'test-repo',
        issue_number: 123,
        labels: ['bug', 'priority:high']
      })
    })

    it('should skip when no labels are provided', async () => {
      const responseWithoutLabels: TriageResponse = {
        labels: [],
        comment: 'No labels',
        needsMoreInfo: false
      }

      await applyLabelsToIssue(mockOctokit, responseWithoutLabels, mockConfig)

      expect(mockAddLabels).not.toHaveBeenCalled()
    })

    it('should skip when labels is undefined', async () => {
      const responseWithUndefinedLabels: TriageResponse = {
        labels: undefined,
        comment: 'No labels',
        needsMoreInfo: false
      }

      await applyLabelsToIssue(mockOctokit, responseWithUndefinedLabels, mockConfig)

      expect(mockAddLabels).not.toHaveBeenCalled()
    })

    it('should filter out empty labels', async () => {
      const responseWithEmptyLabels: TriageResponse = {
        labels: [
          { label: 'bug', confidence: 0.9 },
          { label: '', confidence: 0.8 },
          { label: 'priority:high', confidence: 0.7 }
        ],
        comment: 'Some labels',
        needsMoreInfo: false
      }

      await applyLabelsToIssue(mockOctokit, responseWithEmptyLabels, mockConfig)

      expect(mockAddLabels).toHaveBeenCalledWith({
        owner: 'test-owner',
        repo: 'test-repo',
        issue_number: 123,
        labels: ['bug', 'priority:high']
      })
    })

    it('should skip in dry run mode', async () => {
      const dryRunConfig = { ...mockConfig, dryRun: true }

      await applyLabelsToIssue(mockOctokit, mockTriageResponse, dryRunConfig)

      expect(mockAddLabels).not.toHaveBeenCalled()
      expect(core.info).toHaveBeenCalledWith(
        'Dry run: Skipping applying labels: bug, priority:high'
      )
    })

    it('should handle GitHub API errors', async () => {
      mockAddLabels.mockRejectedValue(new Error('API error'))

      await expect(
        applyLabelsToIssue(mockOctokit, mockTriageResponse, mockConfig)
      ).rejects.toThrow('API error')
    })
  })

  describe('addEyes', () => {
    it('should add eyes reaction to issue', async () => {
      await addEyes(mockOctokit, mockConfig)

      expect(mockCreateForIssue).toHaveBeenCalledWith({
        owner: 'test-owner',
        repo: 'test-repo',
        issue_number: 123,
        content: 'eyes'
      })
    })

    it('should skip in dry run mode', async () => {
      const dryRunConfig = { ...mockConfig, dryRun: true }

      await addEyes(mockOctokit, dryRunConfig)

      expect(mockCreateForIssue).not.toHaveBeenCalled()
      expect(core.info).toHaveBeenCalledWith('Dry run: Skipping adding eyes reaction.')
    })

    it('should handle 409 conflict (reaction already exists)', async () => {
      mockCreateForIssue.mockRejectedValue({ status: 409 })

      await expect(addEyes(mockOctokit, mockConfig)).resolves.not.toThrow()
    })

    it('should handle 200 success', async () => {
      mockCreateForIssue.mockRejectedValue({ status: 200 })

      await expect(addEyes(mockOctokit, mockConfig)).resolves.not.toThrow()
    })

    it('should handle 201 created', async () => {
      mockCreateForIssue.mockRejectedValue({ status: 201 })

      await expect(addEyes(mockOctokit, mockConfig)).resolves.not.toThrow()
    })

    it('should throw on other errors', async () => {
      mockCreateForIssue.mockRejectedValue({ status: 500 })

      await expect(addEyes(mockOctokit, mockConfig)).rejects.toEqual({ status: 500 })
    })

    it('should throw on errors without status', async () => {
      mockCreateForIssue.mockRejectedValue(new Error('Network error'))

      await expect(addEyes(mockOctokit, mockConfig)).rejects.toThrow('Network error')
    })
  })

  describe('removeEyes', () => {
    it('should remove eyes reaction from github-actions[bot]', async () => {
      mockListForIssue.mockResolvedValue({
        data: [
          {
            id: 1,
            content: 'eyes',
            user: { login: 'github-actions[bot]' }
          },
          {
            id: 2,
            content: 'eyes',
            user: { login: 'other-user' }
          },
          {
            id: 3,
            content: '+1',
            user: { login: 'github-actions[bot]' }
          }
        ]
      })

      await removeEyes(mockOctokit, mockConfig)

      expect(mockDeleteForIssue).toHaveBeenCalledTimes(1)
      expect(mockDeleteForIssue).toHaveBeenCalledWith({
        owner: 'test-owner',
        repo: 'test-repo',
        issue_number: 123,
        reaction_id: 1
      })
    })

    it('should skip in dry run mode', async () => {
      const dryRunConfig = { ...mockConfig, dryRun: true }

      await removeEyes(mockOctokit, dryRunConfig)

      expect(mockListForIssue).not.toHaveBeenCalled()
      expect(core.info).toHaveBeenCalledWith('Dry run: Skipping removing eyes reaction.')
    })

    it('should handle no reactions', async () => {
      mockListForIssue.mockResolvedValue({ data: [] })

      await removeEyes(mockOctokit, mockConfig)

      expect(mockDeleteForIssue).not.toHaveBeenCalled()
    })

    it('should handle no github-actions[bot] eyes reactions', async () => {
      mockListForIssue.mockResolvedValue({
        data: [
          {
            id: 1,
            content: '+1',
            user: { login: 'github-actions[bot]' }
          },
          {
            id: 2,
            content: 'eyes',
            user: { login: 'other-user' }
          }
        ]
      })

      await removeEyes(mockOctokit, mockConfig)

      expect(mockDeleteForIssue).not.toHaveBeenCalled()
    })

    it('should handle reactions without user', async () => {
      mockListForIssue.mockResolvedValue({
        data: [
          {
            id: 1,
            content: 'eyes',
            user: null
          }
        ]
      })

      await removeEyes(mockOctokit, mockConfig)

      expect(mockDeleteForIssue).not.toHaveBeenCalled()
    })

    it('should handle GitHub API errors', async () => {
      mockListForIssue.mockRejectedValue(new Error('API error'))

      await expect(removeEyes(mockOctokit, mockConfig)).rejects.toThrow('API error')
    })
  })

  describe('getIssueDetails', () => {
    const mockIssueData = {
      id: 123,
      number: 456,
      title: 'Test Issue',
      body: 'This is a test issue',
      state: 'open',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-02T00:00:00Z',
      closed_at: null,
      comments: 2,
      reactions: {
        total_count: 5,
        '+1': 3,
        '-1': 0,
        laugh: 1,
        hooray: 1,
        confused: 0,
        heart: 0,
        rocket: 0,
        eyes: 0
      },
      user: {
        login: 'test-user',
        id: 100,
        type: 'User'
      },
      assignees: [
        {
          login: 'assignee1',
          id: 200,
          type: 'User'
        }
      ]
    }

    const mockCommentsData = [
      {
        id: 1,
        user: {
          login: 'commenter1',
          id: 300,
          type: 'User'
        },
        created_at: '2023-01-01T12:00:00Z',
        reactions: {
          total_count: 2,
          '+1': 1,
          '-1': 0,
          laugh: 0,
          hooray: 0,
          confused: 0,
          heart: 1,
          rocket: 0,
          eyes: 0
        }
      },
      {
        id: 2,
        user: {
          login: 'commenter2',
          id: 400,
          type: 'User'
        },
        created_at: '2023-01-02T12:00:00Z',
        reactions: {
          total_count: 1,
          '+1': 0,
          '-1': 0,
          laugh: 0,
          hooray: 0,
          confused: 0,
          heart: 0,
          rocket: 1,
          eyes: 0
        }
      }
    ]

    it('should fetch issue details with comments', async () => {
      mockGetIssue.mockResolvedValue({ data: mockIssueData })
      mockListComments.mockResolvedValue({ data: mockCommentsData })

      const result = await getIssueDetails(mockOctokit, 'test-owner', 'test-repo', 456)

      expect(mockGetIssue).toHaveBeenCalledWith({
        owner: 'test-owner',
        repo: 'test-repo',
        issue_number: 456
      })

      expect(mockListComments).toHaveBeenCalledWith({
        owner: 'test-owner',
        repo: 'test-repo',
        issue_number: 456
      })

      expect(result).toEqual({
        id: '123',
        number: 456,
        title: 'Test Issue',
        body: 'This is a test issue',
        state: 'open',
        created_at: '2023-01-01T00:00:00Z',
        updated_at: '2023-01-02T00:00:00Z',
        closed_at: null,
        comments: 2,
        reactions: mockIssueData.reactions,
        comments_data: [
          {
            id: 1,
            user: mockCommentsData[0].user,
            created_at: '2023-01-01T12:00:00Z',
            reactions: mockCommentsData[0].reactions
          },
          {
            id: 2,
            user: mockCommentsData[1].user,
            created_at: '2023-01-02T12:00:00Z',
            reactions: mockCommentsData[1].reactions
          }
        ],
        user: mockIssueData.user,
        assignees: mockIssueData.assignees
      })
    })

    it('should handle issue without body', async () => {
      const issueWithoutBody = { ...mockIssueData, body: null }
      mockGetIssue.mockResolvedValue({ data: issueWithoutBody })
      mockListComments.mockResolvedValue({ data: [] })

      const result = await getIssueDetails(mockOctokit, 'test-owner', 'test-repo', 456)

      expect(result.body).toBe('')
    })

    it('should handle issue without comments', async () => {
      mockGetIssue.mockResolvedValue({ data: mockIssueData })
      mockListComments.mockResolvedValue({ data: [] })

      const result = await getIssueDetails(mockOctokit, 'test-owner', 'test-repo', 456)

      expect(result.comments_data).toEqual([])
    })

    it('should handle GitHub API errors for issue', async () => {
      mockGetIssue.mockRejectedValue(new Error('Issue not found'))

      await expect(
        getIssueDetails(mockOctokit, 'test-owner', 'test-repo', 456)
      ).rejects.toThrow('Issue not found')
    })

    it('should handle GitHub API errors for comments', async () => {
      mockGetIssue.mockResolvedValue({ data: mockIssueData })
      mockListComments.mockRejectedValue(new Error('Comments not found'))

      await expect(
        getIssueDetails(mockOctokit, 'test-owner', 'test-repo', 456)
      ).rejects.toThrow('Comments not found')
    })

    it('should handle closed issue', async () => {
      const closedIssue = {
        ...mockIssueData,
        state: 'closed',
        closed_at: '2023-01-03T00:00:00Z'
      }
      mockGetIssue.mockResolvedValue({ data: closedIssue })
      mockListComments.mockResolvedValue({ data: [] })

      const result = await getIssueDetails(mockOctokit, 'test-owner', 'test-repo', 456)

      expect(result.state).toBe('closed')
      expect(result.closed_at).toBe('2023-01-03T00:00:00Z')
    })

    it('should handle issue without assignees', async () => {
      const issueWithoutAssignees = { ...mockIssueData, assignees: [] }
      mockGetIssue.mockResolvedValue({ data: issueWithoutAssignees })
      mockListComments.mockResolvedValue({ data: [] })

      const result = await getIssueDetails(mockOctokit, 'test-owner', 'test-repo', 456)

      expect(result.assignees).toEqual([])
    })

    it('should handle large number of comments', async () => {
      const manyComments = Array.from({ length: 100 }, (_, i) => ({
        id: i + 1,
        user: {
          login: `commenter${i + 1}`,
          id: 300 + i,
          type: 'User'
        },
        created_at: '2023-01-01T12:00:00Z',
        reactions: {
          total_count: 0,
          '+1': 0,
          '-1': 0,
          laugh: 0,
          hooray: 0,
          confused: 0,
          heart: 0,
          rocket: 0,
          eyes: 0
        }
      }))

      mockGetIssue.mockResolvedValue({ data: mockIssueData })
      mockListComments.mockResolvedValue({ data: manyComments })

      const result = await getIssueDetails(mockOctokit, 'test-owner', 'test-repo', 456)

      expect(result.comments_data).toHaveLength(100)
    })
  })
})