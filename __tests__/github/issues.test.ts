import { jest } from '@jest/globals'
import * as fs from 'fs'
import * as core from '../../__fixtures__/actions/core.js'
import { octokit, mockOctokit } from '../../__fixtures__/actions/github.js'
import { getSdk, mockGetSdk } from '../../__fixtures__/generated/graphql.js'
import { FileSystemMock } from '../helpers/filesystem-mock.js'

import * as realIssues from '../query-data/issue-details.js'
import { IssueState, GetIssueDetailsQuery } from '../../src/generated/graphql.js'

type GetIssueDetailsQueryIssueCommentNodes = NonNullable<
  NonNullable<NonNullable<NonNullable<GetIssueDetailsQuery['repository']>['issue']>['comments']>['nodes']
>

// Mock dependencies using fixtures
jest.unstable_mockModule('@actions/core', () => core)

// Import the module being tested
const { commentOnIssue, applyLabelsToIssue, addEyes, removeEyes, getIssueDetails, searchIssues } = await import(
  '../../src/github/issues.js'
)

describe('GitHub Issues', () => {
  const testTempDir = '/tmp/test'

  const mockConfig = {
    dryRun: false,
    token: 'test-token',
    tempDir: testTempDir,
    issueNumber: 123,
    repository: 'owner/repo',
    repoName: 'repo',
    repoOwner: 'owner',
    aiEndpoint: 'test-endpoint',
    aiModel: 'test-model',
    aiToken: 'test-ai-token',
    applyComment: true,
    applyLabels: true,
    commentFooter: 'Test footer'
  }

  const inMemoryFs = new FileSystemMock()

  beforeEach(() => {
    jest.clearAllMocks()
    jest.resetAllMocks()

    // Mock file system operations
    inMemoryFs.setup()
  })

  afterEach(() => {
    jest.restoreAllMocks()
    inMemoryFs.teardown()
  })

  describe('commentOnIssue', () => {
    it('should create comment from summary file', async () => {
      const mockSummary = 'This is a test summary'
      const mockFooter = 'Generated by AI'
      inMemoryFs.forceSet('/tmp/summary.txt', mockSummary)

      await commentOnIssue(octokit, '/tmp/summary.txt', mockConfig, mockFooter)

      expect(fs.promises.readFile).toHaveBeenCalledWith('/tmp/summary.txt', 'utf8')
      expect(octokit.rest.issues.createComment).toHaveBeenCalledWith({
        owner: 'owner',
        repo: 'repo',
        issue_number: 123,
        body: `
${mockSummary}

${mockFooter}
`.trim()
      })
    })

    it('should skip empty comments', async () => {
      inMemoryFs.forceSet('/tmp/summary.txt', '')

      await commentOnIssue(octokit, '/tmp/summary.txt', mockConfig, '')

      expect(octokit.rest.issues.createComment).not.toHaveBeenCalled()
    })

    it('should skip comments in dry run mode', async () => {
      const dryRunConfig = { ...mockConfig, dryRun: true }
      inMemoryFs.forceSet('/tmp/summary.txt', 'Test summary')

      await commentOnIssue(octokit, '/tmp/summary.txt', dryRunConfig, 'Footer')

      expect(octokit.rest.issues.createComment).not.toHaveBeenCalled()
      expect(core.info).toHaveBeenCalledWith(expect.stringContaining('Dry run: Skipping commenting on issue'))
    })

    it('should handle comment without footer', async () => {
      const mockSummary = 'Test summary'
      inMemoryFs.forceSet('/tmp/summary.txt', mockSummary)

      await commentOnIssue(octokit, '/tmp/summary.txt', mockConfig)

      expect(octokit.rest.issues.createComment).toHaveBeenCalledWith({
        owner: 'owner',
        repo: 'repo',
        issue_number: 123,
        body: mockSummary
      })
    })

    it('should handle file read errors', async () => {
      await expect(commentOnIssue(octokit, '/tmp/summary.txt', mockConfig)).rejects.toThrow('File not found')
    })

    it('should handle GitHub API errors', async () => {
      const mockSummary = 'Test summary'
      inMemoryFs.forceSet('/tmp/summary.txt', mockSummary)
      mockOctokit.rest.issues.createComment.mockRejectedValue(new Error('API error'))

      await expect(commentOnIssue(octokit, '/tmp/summary.txt', mockConfig)).rejects.toThrow('API error')
    })
  })

  describe('applyLabelsToIssue', () => {
    const mockLabels = ['bug', 'area-ui']

    it('should apply labels from triage response', async () => {
      await applyLabelsToIssue(octokit, mockLabels, mockConfig)

      expect(octokit.rest.issues.addLabels).toHaveBeenCalledWith({
        owner: 'owner',
        repo: 'repo',
        issue_number: 123,
        labels: ['bug', 'area-ui']
      })
    })

    it('should skip when no labels are provided', async () => {
      await applyLabelsToIssue(octokit, [], mockConfig)

      expect(octokit.rest.issues.addLabels).not.toHaveBeenCalled()
    })

    it('should skip when only empty labels are provided', async () => {
      await applyLabelsToIssue(octokit, [''], mockConfig)

      expect(octokit.rest.issues.addLabels).not.toHaveBeenCalled()
    })

    it('should skip when labels is undefined', async () => {
      await applyLabelsToIssue(octokit, undefined, mockConfig)

      expect(octokit.rest.issues.addLabels).not.toHaveBeenCalled()
    })

    it('should filter out empty labels', async () => {
      await applyLabelsToIssue(octokit, [...mockLabels, ''], mockConfig)

      expect(octokit.rest.issues.addLabels).toHaveBeenCalledWith({
        owner: 'owner',
        repo: 'repo',
        issue_number: 123,
        labels: ['bug', 'area-ui']
      })
    })

    it('should skip in dry run mode', async () => {
      const dryRunConfig = { ...mockConfig, dryRun: true }

      await applyLabelsToIssue(octokit, mockLabels, dryRunConfig)

      expect(octokit.rest.issues.addLabels).not.toHaveBeenCalled()
      expect(core.info).toHaveBeenCalledWith('Dry run: Skipping applying labels: bug, area-ui')
    })

    it('should handle GitHub API errors', async () => {
      mockOctokit.rest.issues.addLabels.mockRejectedValue(new Error('API error'))

      await expect(applyLabelsToIssue(octokit, mockLabels, mockConfig)).rejects.toThrow('API error')
    })
  })

  describe('addEyes', () => {
    it('should add eyes reaction to issue', async () => {
      await addEyes(octokit, mockConfig)

      expect(octokit.rest.reactions.createForIssue).toHaveBeenCalledWith({
        owner: 'owner',
        repo: 'repo',
        issue_number: 123,
        content: 'eyes'
      })
    })

    it('should skip in dry run mode', async () => {
      const dryRunConfig = { ...mockConfig, dryRun: true }

      await addEyes(octokit, dryRunConfig)

      expect(octokit.rest.reactions.createForIssue).not.toHaveBeenCalled()
      expect(core.info).toHaveBeenCalledWith('Dry run: Skipping adding eyes reaction.')
    })

    const expectedErrors = [
      409, // reaction already exists
      200, // success
      201 // created
    ]
    for (const status of expectedErrors) {
      it(`should handle ${status} status code`, async () => {
        mockOctokit.rest.reactions.createForIssue.mockRejectedValue({ status })

        await expect(addEyes(octokit, mockConfig)).resolves.not.toThrow()
      })
    }

    it('should throw on other errors', async () => {
      mockOctokit.rest.reactions.createForIssue.mockRejectedValue({ status: 500 })

      await expect(addEyes(octokit, mockConfig)).rejects.toEqual({ status: 500 })
    })

    it('should throw on errors without status', async () => {
      mockOctokit.rest.reactions.createForIssue.mockRejectedValue(new Error('Network error'))

      await expect(addEyes(octokit, mockConfig)).rejects.toThrow('Network error')
    })
  })

  describe('removeEyes', () => {
    it('should remove eyes reaction from github-actions[bot]', async () => {
      const mockResponse = {
        data: [
          {
            id: 1,
            content: 'eyes',
            user: { login: 'github-actions[bot]' }
          },
          {
            id: 2,
            content: 'eyes',
            user: { login: 'other-user' }
          },
          {
            id: 3,
            content: '+1',
            user: { login: 'github-actions[bot]' }
          }
        ]
      } as unknown as Awaited<ReturnType<typeof mockOctokit.rest.reactions.listForIssue>>

      mockOctokit.rest.reactions.listForIssue.mockResolvedValue(mockResponse)

      await removeEyes(octokit, mockConfig)

      expect(octokit.rest.reactions.deleteForIssue).toHaveBeenCalledTimes(1)
      expect(octokit.rest.reactions.deleteForIssue).toHaveBeenCalledWith({
        owner: 'owner',
        repo: 'repo',
        issue_number: 123,
        reaction_id: 1
      })
    })

    it('should skip in dry run mode', async () => {
      const dryRunConfig = { ...mockConfig, dryRun: true }

      await removeEyes(octokit, dryRunConfig)

      expect(octokit.rest.reactions.listForIssue).not.toHaveBeenCalled()
      expect(core.info).toHaveBeenCalledWith('Dry run: Skipping removing eyes reaction.')
    })

    it('should handle no reactions', async () => {
      const mockResponse = {
        data: []
      } as unknown as Awaited<ReturnType<typeof mockOctokit.rest.reactions.listForIssue>>

      mockOctokit.rest.reactions.listForIssue.mockResolvedValue(mockResponse)

      await removeEyes(octokit, mockConfig)

      expect(octokit.rest.reactions.deleteForIssue).not.toHaveBeenCalled()
    })

    it('should handle no github-actions[bot] eyes reactions', async () => {
      const mockResponse = {
        data: [
          {
            id: 1,
            content: '+1',
            user: { login: 'github-actions[bot]' }
          },
          {
            id: 2,
            content: 'eyes',
            user: { login: 'other-user' }
          }
        ]
      } as unknown as Awaited<ReturnType<typeof mockOctokit.rest.reactions.listForIssue>>

      mockOctokit.rest.reactions.listForIssue.mockResolvedValue(mockResponse)

      await removeEyes(octokit, mockConfig)

      expect(mockOctokit.rest.reactions.deleteForIssue).not.toHaveBeenCalled()
    })

    it('should handle reactions without user', async () => {
      const mockResponse = {
        data: [
          {
            id: 1,
            content: 'eyes',
            user: null
          }
        ]
      } as unknown as Awaited<ReturnType<typeof mockOctokit.rest.reactions.listForIssue>>

      mockOctokit.rest.reactions.listForIssue.mockResolvedValue(mockResponse)

      await removeEyes(octokit, mockConfig)

      expect(mockOctokit.rest.reactions.deleteForIssue).not.toHaveBeenCalled()
    })

    it('should handle GitHub API errors', async () => {
      mockOctokit.rest.reactions.listForIssue.mockRejectedValue(new Error('API error'))

      await expect(removeEyes(octokit, mockConfig)).rejects.toThrow('API error')
    })
  })

  describe('getIssueDetails', () => {
    it('should fetch issue details with comments', async () => {
      mockGetSdk.GetIssueDetails.mockResolvedValue(realIssues.issue32())

      const result = await getIssueDetails(getSdk, 'mattleibow', 'triage-assistant', 32)

      expect(getSdk.GetIssueDetails).toHaveBeenCalledWith({
        owner: 'mattleibow',
        repo: 'triage-assistant',
        issueNumber: 32
      })
      expect(result).toEqual({
        id: 'I_kwDOOy552s7ComT5',
        owner: 'mattleibow',
        repo: 'triage-assistant',
        number: 32,
        title: 'An issue for the unit tests',
        body: '## Description\n\nThis is an issue for the unit tests and not a real one.\n\nWe need some real data to allow for real tests.',
        state: 'open',
        createdAt: new Date('2025-07-26T10:36:49Z'),
        updatedAt: new Date('2025-07-26T10:38:08Z'),
        closedAt: null,
        comments: [
          {
            createdAt: new Date('2025-07-26T10:38:07Z'),
            reactions: [],
            user: {
              login: 'github-actions',
              type: 'Bot'
            }
          }
        ],
        reactions: [
          {
            createdAt: new Date('2025-07-26T10:37:24Z'),
            reaction: 'rocket',
            user: {
              login: 'mattleibow',
              type: 'User'
            }
          },
          {
            createdAt: new Date('2025-07-26T10:37:26Z'),
            reaction: 'thumbs_up',
            user: {
              login: 'mattleibow',
              type: 'User'
            }
          },
          {
            createdAt: new Date('2025-07-27T19:12:56Z'),
            reaction: 'eyes',
            user: {
              login: 'Copilot',
              type: 'User'
            }
          }
        ],
        user: {
          login: 'mattleibow',
          type: 'User'
        },
        assignees: [
          {
            login: 'mattleibow',
            type: 'User'
          },
          {
            login: 'Copilot',
            type: 'User'
          }
        ]
      })
    })

    it('should handle issue without body', async () => {
      const issueWithoutBody = realIssues.issue32()
      issueWithoutBody.repository!.issue!.body = ''
      mockGetSdk.GetIssueDetails.mockResolvedValue(issueWithoutBody)

      const result = await getIssueDetails(getSdk, 'mattleibow', 'triage-assistant', 32)

      expect(result.body).toBe('')
    })

    it('should handle issue without comments', async () => {
      const issueWithoutComments = realIssues.issue32()
      issueWithoutComments.repository!.issue!.comments = {
        totalCount: 0,
        pageInfo: {
          hasNextPage: false,
          endCursor: null
        },
        nodes: []
      }
      mockGetSdk.GetIssueDetails.mockResolvedValue(issueWithoutComments)

      const result = await getIssueDetails(getSdk, 'mattleibow', 'triage-assistant', 32)

      expect(result.comments).toEqual([])
    })

    it('should handle GitHub API errors for issue', async () => {
      mockGetSdk.GetIssueDetails.mockRejectedValue(new Error('Issue not found'))

      await expect(getIssueDetails(getSdk, 'owner', 'repo', 456)).rejects.toThrow('Issue not found')
    })

    it('should handle GraphQL errors for missing issue', async () => {
      const responseWithoutIssue = realIssues.issue32()
      responseWithoutIssue.repository!.issue = null
      mockGetSdk.GetIssueDetails.mockResolvedValue(responseWithoutIssue)

      await expect(getIssueDetails(getSdk, 'owner', 'repo', 456)).rejects.toThrow('Issue not found: owner/repo#456')
    })

    it('should handle closed issue', async () => {
      const closedIssue = realIssues.issue32()
      closedIssue.repository!.issue!.state = IssueState.Closed
      closedIssue.repository!.issue!.closedAt = '2023-01-03T00:00:00Z'
      mockGetSdk.GetIssueDetails.mockResolvedValue(closedIssue)

      const result = await getIssueDetails(getSdk, 'mattleibow', 'triage-assistant', 32)

      expect(result.state).toBe('closed')
      expect(result.closedAt).toEqual(new Date('2023-01-03T00:00:00Z'))
    })

    it('should handle issue without assignees', async () => {
      const issueWithoutAssignees = realIssues.issue32()
      issueWithoutAssignees.repository!.issue!.assignees = {
        nodes: []
      }
      mockGetSdk.GetIssueDetails.mockResolvedValue(issueWithoutAssignees)

      const result = await getIssueDetails(getSdk, 'mattleibow', 'triage-assistant', 32)

      expect(result.assignees).toEqual([])
    })

    it('should handle large number of comments', async () => {
      const manyComments: GetIssueDetailsQueryIssueCommentNodes = Array.from({ length: 100 }, (_, i) => ({
        author: {
          login: `commenter${i + 1}`,
          __typename: 'User'
        },
        createdAt: '2023-01-01T12:00:00Z',
        reactions: {
          totalCount: 0,
          pageInfo: {
            hasNextPage: false,
            endCursor: null
          },
          nodes: []
        }
      }))
      const issueWithManyComments = realIssues.issue32()
      issueWithManyComments.repository!.issue!.comments = {
        totalCount: 100,
        pageInfo: {
          hasNextPage: false,
          endCursor: null
        },
        nodes: manyComments
      }
      mockGetSdk.GetIssueDetails.mockResolvedValue(issueWithManyComments)

      const result = await getIssueDetails(getSdk, 'mattleibow', 'triage-assistant', 32)
      expect(result.comments).toHaveLength(100)
      expect(result.comments[0].user.login).toBe('commenter1')
      expect(result.comments[99].user.login).toBe('commenter100')
    })
  })

  describe('searchIssues', () => {
    it('should search for issues using GitHub API', async () => {
      const mockSearchResponse = {
        data: {
          total_count: 2,
          incomplete_results: false,
          items: [
            {
              id: 1,
              number: 101,
              pull_request: null
            },
            {
              id: 2,
              number: 102,
              pull_request: null
            }
          ]
        },
        headers: {},
        status: 200,
        url: 'https://api.github.com/search/issues'
      } as any

      mockOctokit.rest.search.issuesAndPullRequests.mockResolvedValue(mockSearchResponse)

      const result = await searchIssues(octokit, 'is:issue state:open', 'owner', 'repo')

      expect(mockOctokit.rest.search.issuesAndPullRequests).toHaveBeenCalledWith({
        q: 'is:issue state:open repo:owner/repo',
        sort: 'created',
        order: 'desc',
        per_page: 100
      })

      expect(result).toEqual([
        { id: '1', owner: 'owner', repo: 'repo', number: 101 },
        { id: '2', owner: 'owner', repo: 'repo', number: 102 }
      ])
    })

    it('should not add repo scope if already present in query', async () => {
      const mockSearchResponse = {
        data: {
          total_count: 1,
          incomplete_results: false,
          items: [
            {
              id: 1,
              number: 101,
              pull_request: null
            }
          ]
        },
        headers: {},
        status: 200,
        url: 'https://api.github.com/search/issues'
      } as any

      mockOctokit.rest.search.issuesAndPullRequests.mockResolvedValue(mockSearchResponse)

      await searchIssues(octokit, 'is:issue repo:owner/repo state:open', 'owner', 'repo')

      expect(mockOctokit.rest.search.issuesAndPullRequests).toHaveBeenCalledWith({
        q: 'is:issue repo:owner/repo state:open',
        sort: 'created',
        order: 'desc',
        per_page: 100
      })
    })

    it('should filter out pull requests', async () => {
      const mockSearchResponse = {
        data: {
          total_count: 3,
          incomplete_results: false,
          items: [
            {
              id: 1,
              number: 101,
              pull_request: null // This is an issue
            },
            {
              id: 2,
              number: 102,
              pull_request: { url: 'https://api.github.com/repos/owner/repo/pulls/102' } // This is a PR
            },
            {
              id: 3,
              number: 103,
              pull_request: null // This is an issue
            }
          ]
        },
        headers: {},
        status: 200,
        url: 'https://api.github.com/search/issues'
      } as any

      mockOctokit.rest.search.issuesAndPullRequests.mockResolvedValue(mockSearchResponse)

      const result = await searchIssues(octokit, 'is:issue state:open', 'owner', 'repo')

      // Should only return issues, not pull requests
      expect(result).toEqual([
        { id: '1', owner: 'owner', repo: 'repo', number: 101 },
        { id: '3', owner: 'owner', repo: 'repo', number: 103 }
      ])
    })

    it('should handle empty search results', async () => {
      const mockSearchResponse = {
        data: {
          total_count: 0,
          incomplete_results: false,
          items: []
        },
        headers: {},
        status: 200,
        url: 'https://api.github.com/search/issues'
      } as any

      mockOctokit.rest.search.issuesAndPullRequests.mockResolvedValue(mockSearchResponse)

      const result = await searchIssues(octokit, 'is:issue state:open', 'owner', 'repo')

      expect(result).toEqual([])
    })

    it('should handle search API errors', async () => {
      const error = new Error('Search API rate limit exceeded')
      mockOctokit.rest.search.issuesAndPullRequests.mockRejectedValue(error)

      await expect(searchIssues(octokit, 'is:issue state:open', 'owner', 'repo')).rejects.toThrow(
        'Search API rate limit exceeded'
      )

      expect(core.error).toHaveBeenCalledWith('Failed to search for issues: Error: Search API rate limit exceeded')
    })
  })
})
